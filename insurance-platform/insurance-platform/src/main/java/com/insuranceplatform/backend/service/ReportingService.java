package com.insuranceplatform.backend.service;

import com.insuranceplatform.backend.entity.Transaction;
import com.insuranceplatform.backend.repository.TransactionRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.stream.Stream;

@Service
@RequiredArgsConstructor
public class ReportingService {

    private final TransactionRepository transactionRepository;

    /**
     * Generates a CSV report of all transactions and returns it as a Resource.
     * This method is highly memory-efficient as it uses JPA streaming to process
     * transactions one by one, rather than loading the entire dataset into memory.
     *
     * @return A Resource object containing the CSV data, ready for streaming.
     */
    @Transactional(readOnly = true) // Important for efficient database streaming
    public Resource generateTransactionsCsvAsResource() {
        // Define the CSV header
        final String[] csvHeader = {
            "TransactionID", "PolicyID", "AgentID", "AgentName", "Amount", "TransactionType", "Timestamp"
        };

        // Using ByteArrayOutputStream to build the CSV in memory before serving.
        // This is safe because we write to it line-by-line from a stream.
        try (
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            // PrintWriter makes writing text and new lines easier
            PrintWriter writer = new PrintWriter(out);
        ) {
            // Write the header row
            writer.println(String.join(",", csvHeader));

            // Use try-with-resources on the JPA stream to ensure it's closed properly
            try (Stream<Transaction> transactionStream = transactionRepository.streamAll()) {
                // Process each transaction from the stream and write it to the CSV
                transactionStream.forEach(tx -> {
                    String[] data = {
                        escapeCsvField(tx.getId().toString()),
                        escapeCsvField(tx.getPolicy() != null ? tx.getPolicy().getId().toString() : "N/A"),
                        escapeCsvField(tx.getWallet().getUser().getId().toString()),
                        escapeCsvField(tx.getWallet().getUser().getFullName()),
                        escapeCsvField(tx.getAmount().toString()),
                        escapeCsvField(tx.getTransactionType().name()),
                        escapeCsvField(tx.getTimestamp().toString())
                    };
                    writer.println(String.join(",", data));
                });
            }

            writer.flush(); // Ensure all data is written to the underlying stream

            // Create an InputStreamResource from the generated byte array
            return new InputStreamResource(new ByteArrayInputStream(out.toByteArray()));

        } catch (IOException e) {
            // This is unlikely to happen with ByteArrayOutputStream, but it's good practice
            throw new RuntimeException("Failed to generate CSV file: " + e.getMessage(), e);
        }
    }

    /**
     * A helper method to escape fields in a CSV. If a field contains a comma,
     * it wraps the field in double quotes to prevent breaking the CSV format.
     *
     * @param field The string data for a single CSV cell.
     * @return The sanitized, safe string for the CSV cell.
     */
    private String escapeCsvField(String field) {
        if (field == null) {
            return "";
        }
        // If the field contains a comma, a double quote, or a newline, wrap it in double quotes.
        if (field.contains(",") || field.contains("\"") || field.contains("\n")) {
            // Also, any double quotes within the field must be escaped by another double quote.
            return "\"" + field.replace("\"", "\"\"") + "\"";
        }
        return field;
    }
}